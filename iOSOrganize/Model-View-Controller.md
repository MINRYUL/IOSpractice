# Model-View-Controller

- MVC 디자인 패턴은 애플리케이션이 객체를 모델, 뷰, 컨트롤러의 세 가지 역할 중 하나의 역할로 할당. 이 패턴은 애플리케이션 내에서 객체가 수행하는 역할 뿐만 아니라 객체가 서로 통신하는 방식을 정의. 세 가지 유형의 객체는 각각 추상적인 경계에 의해 다른 객체와 구분되며, 그 경계를 넘어 다른 유형의 객체와 통신. 애플리케이션 내의 특정 MVC유형을 한데 모다 레이어라고도 한다.

**Model Objects**

---

- 애플리케이션과 관련된 데이터를 캡슐화하고, 해당 데이터를 조작하고 처리하는 로직과 계산을 정의. 하나의 모델 객체는 다른 모델 객체와 일대일 또는 일대다 대응 관계를 맺을 수 있다. 모델 객체는 데이터를 사용자에게 제공하거나 사용자가 이를 편집할 수 있는 뷰 객체에 명시적으로 연결되어서는 안된다. 사용자 인터페이스나 표시 문제와 관련이 있어서는 안된다.
- 잘 설계된 모델 클래스
    - 모델 클래스, 즉 모델 객체를 생성하는 클래스는 Core Data technology를 사용하고 있는 경우 NSManagerdObject 서브 클래스를 많이 사용. Objective-C언어를 사용하는 경우 모델 클래스는 일반적으로 NSObject의 서브클래스이다. 스위프트 언어를 사용하는 경우에는 특별한 경우가 아니라면 NSObject를 상속받지 않음. 또, 값 타입의 모델이 필요한 경우 클래스 대신에 구조체를 활용하기도 한다.
    - 인스턴스 변수
        - 애플리케이션 내에 캡슐화된 데이터를 유지하기 위한 인스턴스 변수를 선언. 인스턴스 변수는 객체, 스칼라 값, 또는 NSRange와 같은 구조체(structure)일 수 있음. 비객체형(nonobject types) 대신 객체형을 사용하는 데에는 장단점이 있으므로, 객체 상호 관계(object mutuality)를 고려해야 한다.
    - 접근자 메서드(Accessor methods)와 프로퍼티
        - 접근자 메서드는 일반저으로 인스턴스 변숫값을 획득 및 설정하며, 흔히 휙득자 및 설정자 메서드(getter and setter methods)라고도 알려져 있다. 스위프트의 언어를 사용하는 경우, 인스턴스 변수를 private 또는 fileprivate 등으로 접근을 제한한 경우, 인스턴스 외부에서(fileprivate의 경우는 다른 소스파일에서) 접근하려면 접근자 메서드가 필요함.
    - 키-값(key-value) 코딩
        - 키-값 코딩은 클라이언트가 프로퍼티 이름을 키로 사용하여 객체의 프로퍼티에 접근할 수 있게 하는 메커니즘. Core Data에서 사용하고 있으며 Cocoa의 다른 곳에서도 사용하고 있음. 접근자 메서드의 이름 지정(또한, 암시적을는 선언된 프로퍼티의 이름 지정)이 이 메너니즘의 요소.
    - 초기화 및 할당 해제(Initialization and deallocation)
        - 대부분 모델 클래스는 인스턴스 변수를 적절한 초깃값으로 설정하는 이니셜라이즈 메서드를 구현함. 여기서 초기화는 이니셜라이저 메서드의 표준 형식을 따라야 하며, deinit 메서드에서 객체 값을 가지는 모든 인스턴스 변수를 해제해야 한다.
    - 객체 인코딩
        - 모델 클래스의 객체를 보관하려는 경우, 해당 객체의 인스턴스 변수를 인코딩 및 디코딩할 수 있어야 한다.
    - 객체 복제
        - 클라이언트가 모델 객체를 복제할 것으로 예상하는 경우, 클래스에서 객체 복제를 구현해야 한다.

**View Objects**

---

- 뷰 객체는 애플리케이션 내에서 사용자가 볼 수 있는 객체. 자신이 보이는 방법을 알고 있고 사용자 동작에 응답할 수 있다. 뷰 객체의 주된 목적은 애플리케이션의 모델 객체의 데이터를 보여주고 해당 데이터를 편집할 수 있도록 하는 것. 뷰 객체는 MVC 애플리케이션의 모델 객체와는 일반적으로 분리된다. 주소록을 예를 들면 전화번호 및 정보가 보이는 화면들을 말한다.

**Controller Objects**

---

- 컨트롤러 객체는 하나 이상의 애플리케이션 뷰 객체와 하나 이상의 모델 객체 사이의 코디네이터 또는 중개자 역할을 한다. 모델-뷰-컨트롤러 디자인 패턴에서 컨트롤러 객체(또는 컨트롤러)는 사용자가 버튼을 탭/클릭하거나 텍스트 필드에서 텍스트를 입력하는 것처럼, 뷰 객체에서 이루어진 사용자 동작 및 의도를 해석, 신규 혹은 변경된 데이터를 모델 객체에 전달. 따라서 컨트롤러 객체는 뷰 객체로 하여금 모델 객체의 변경사항을 인지하거나, 그 반대의 경우가 가능하도록 하는 매개체가 된다. 컨트롤러 객체는 애플리케이션의 설정 및 조정 작업을 수행할 수도 있으며, 다른 객체들의 생애주기(life cycle)를 관리하기도 한다. iOS 환경의 Cocoa Touch 프레임워크는 코디네이팅 컨트롤러, 뷰 컨트롤러의 두 가지 기본 컨트롤러 유형을 제공.

- 코디네이팅 컨트롤러(Coordinating Controllers)
    - 코디네이팅 컨트롤러는 애플리케이션 전체 혹은 일부 기능을 감독하고 관리 한다. 애플리케이션별로 다른 로직이 각 애플리케이션에 주입(injected)되는 장소라고 할 수 있다
        - 델리케이션(delegation) 메세지에 응답하고 알림(notifications)을 관리.
        - 사용자가 버튼과 같은 컨트롤 탭 하거나 클릭함에 따라 전송되는 동작 메시지(action message)에 응답.
        - 객체 간의 연결을 확립하거나 기타 설정 작업을 수행. (예: 애플리케이션을 시작하는 경우)
        - 소유한(owned) 객체의 생명 주기 관리.
    - iOS 애플리케이션에서는 뷰 컨트롤러가 코디네이팅 컨트롤러의 역할을 겸하는 경우가 많습니다.

- 뷰 컨트롤러(View Controller)
    - UIKit에서 뷰 컨트롤러는 콘텐츠를 화면에 표시하는 뷰를 관리하며, 해당 뷰에 대한 참조(reference)를 유지하고, 뷰 컨트롤러는 이 뷰의 프레젠테이션(presentation) 및 후속 뷰로의 전환(transition)을 관리. 이와 관련된 모든 프레젠테이션 동작 뷰 컨트롤러 객체에 의해 관리되고 구현. 또한, 모달뷰를 표시하고 메모리 부족 경고에 응답하며 기기의 방향(orientation)이 바뀔 때 뷰를 회전.
    - iOS의 뷰 컨트롤러는 UIViewController 서브클래스의 인스턴스. UIKit은 UITableViewController와 같은, UIViewController의 여러 특수 목적 서브클래스를 제공. 컨트롤러가 모델과 뷰 간에 데이터를 중개하도록 반드시 프레임워크의 뷰-컨트롤러 클래스(예 : UIViewController, UITableViewController 등)를 확장해야 한다. 뷰 컨트롤러는 여러 가지 프레임워크 객체에 대한 델리게이트 혹은 데이터 소스 객체인 경우가 많음.